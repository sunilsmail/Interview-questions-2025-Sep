# JavaScript, Angular & Design Concepts ‚Äì Interview Q&A

---

## 1. Creating Set and Get Methods on Object Properties
You can define getters and setters using object shorthand or `Object.defineProperty`.

```js
const user = {
  firstName: "John",
  lastName: "Doe",
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(" ");
  },
};

console.log(user.fullName); // John Doe
user.fullName = "Jane Smith";
console.log(user.firstName); // Jane
```

## 2. target vs currentTarget

event.target ‚Üí The actual element clicked.

event.currentTarget ‚Üí The element the handler is attached to.

```js
document.querySelector("#parent").addEventListener("click", (e) => {
  console.log(e.target.id);        // child
  console.log(e.currentTarget.id); // parent
});
```

## 3. stopPropagation vs stopImmediatePropagation

stopPropagation() ‚Üí Stops further bubbling/capturing.

stopImmediatePropagation() ‚Üí Stops bubbling and prevents other listeners on the same element.

```htnl
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#cce5ff;">
      Parent
      <button id="child" style="margin:20px;">Click Me</button>
    </div>

    <script>
      // Parent listener
      document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked");
      });

      // Child listener 1
      document.getElementById("child").addEventListener("click", (e) => {
        console.log("Child listener 1");
        // Uncomment ONE of these lines at a time to see difference:
        // e.stopPropagation();
        // e.stopImmediatePropagation();
      });

      // Child listener 2
      document.getElementById("child").addEventListener("click", () => {
        console.log("Child listener 2");
      });
    </script>
  </body>
</html>

```
What happens:

Without any stop method

Child listener 1
Child listener 2
Parent clicked


With stopPropagation() inside listener 1

Child listener 1
Child listener 2


üëâ Event doesn‚Äôt bubble to parent, but other listeners on the child still run.

With stopImmediatePropagation() inside listener 1

Child listener 1


üëâ Stops bubbling and prevents Child listener 2 from running.


## 4. Currying

```js
function sum(a) {
  return (b) => (c) => a + b + c;
}
console.log(sum(1)(2)(3)); // 6

```


## 5. Higher Order Function

A function that takes another function as an argument or returns a function.

```js
function hof(fn, x) {
  return fn(x);
}
hof((n) => n * 2, 5); // 10

```


## 6. function sum(){} var sum; console.log(sum)

```js
function sum() {}
var sum;
console.log(sum); // function sum() {}

What happens under the hood:

Function declarations are hoisted first ‚Üí The identifier sum is assigned to the function.

var declarations are hoisted next, but only the declaration (not assignment) is hoisted.

i.e. var sum; does nothing here because sum is already declared by the function.

So the final effective code is:

function sum() {}  // stays as is
// var sum; ‚Üê ignored because already declared
console.log(sum);  // logs function


‚úÖ Function declarations take precedence over var declarations during hoisting.

üîπ Another Example (with assignment)
function sum() {}
var sum = 10;
console.log(sum);


üëâ Output: 10
Because:

Function hoisted first (sum = function).

Then var sum hoisted (ignored, since already declared).

But assignment = 10 happens at runtime ‚Üí overwrites function.
```

## 7. Design Principle ‚Äì DRY

Don‚Äôt Repeat Yourself (DRY): Extract common logic into reusable functions or modules.

## 8. Design Patterns

Reusable solutions:

Singleton

Observer

Factory

Decorator

Module Pattern

## 9. Difference b/w Map & Reduce

map() ‚Üí Transforms each element ‚Üí returns array.

reduce() ‚Üí Combines values ‚Üí returns single result.

## 10. Update Array Without Modifying Reference
```js
const arr = [1, 2, 3, 4];
const updated = [...arr.slice(0, 2), 10, ...arr.slice(3)];
console.log(updated); // [1, 2, 10, 4]

```

## 11. Async Pipe in *ngFor

Using async directly in *ngFor ‚Üí multiple subscriptions (performance issue).
‚úÖ Better: assign observable to a variable via async with ngIf.

## 12. Custom Pipe, Resolver, Interceptor

```js
Pipe:

@Pipe({ name: 'capitalize' })
export class CapitalizePipe implements PipeTransform {
  transform(value: string): string {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
}
Resolver:

@Injectable({ providedIn: 'root' })
export class UserResolver implements Resolve<User> {
  constructor(private service: UserService) {}
  resolve() { return this.service.getUser(); }
}


Interceptor:

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req, next) {
    const cloned = req.clone({ setHeaders: { Authorization: 'token' } });
    return next.handle(cloned);
  }
}
```


## 2. target vs currentTarget

event.target ‚Üí The actual element clicked.

event.currentTarget ‚Üí The element the handler is attached to.

```js
document.querySelector("#parent").addEventListener("click", (e) => {
  console.log(e.target.id);        // child
  console.log(e.currentTarget.id); // parent
});
```

## 13. Test Case for HTTP Request

```js
it('should call API', () => {
  const http = TestBed.inject(HttpTestingController);
  service.getData().subscribe(data => expect(data).toEqual({ name: 'test' }));
  const req = http.expectOne('/api/data');
  req.flush({ name: 'test' });
});

```

## 14. Event Bubbling vs Capturing vs Delegation

```js
Bubbling (child ‚Üí parent)
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#cce5ff;">
      Parent
      <button id="child" style="margin:20px;">Click Me</button>
    </div>

    <script>
      document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked (bubbling)");
      });

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked (bubbling)");
      });
    </script>
  </body>
</html>


üëâ Output when clicking Child:

Child clicked (bubbling)
Parent clicked (bubbling)

Capturing (parent ‚Üí child)
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#f8d7da;">
      Parent
      <button id="child">Click Me</button>
    </div>

    <script>
      document.getElementById("parent").addEventListener(
        "click",
        () => {
          console.log("Parent clicked (capturing)");
        },
        true // üëà capture mode enabled
      );

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked (capturing)");
      });
    </script>
  </body>
</html>
Output when clicking Child:

Parent clicked (capturing)
Child clicked (capturing)

Delegation (parent handles child events)
<!DOCTYPE html>
<html>
  <body>
    <ul id="list" style="cursor:pointer;">
      <li data-id="1">Item 1</li>
      <li data-id="2">Item 2</li>
      <li data-id="3">Item 3</li>
    </ul>

    <script>
      document.getElementById("list").addEventListener("click", (e) => {
        if (e.target.tagName === "LI") {
          console.log("Clicked item id:", e.target.dataset.id);
        }
      });
    </script>
  </body>
</html>


üëâ Output when clicking Item 2:

Clicked item id: 2
```

## 15. Properties vs Attributes

Attributes: Present in HTML (e.g., <input value="abc">).

Properties: DOM object representation (input.value = "abc").

## 16. Pure vs Impure Pipe

Pure Pipe: Executes only when input changes.

Impure Pipe: Executes on every change detection.

## 17. innerText vs innerHTML

innerText: Returns visible text.

innerHTML: Returns/sets HTML including tags.

## 18. Polymorphism in JS

```js
function sum(a) {
  return (b) => () => a + b;
}
console.log(sum(1)(2)()); // 3


```


## 19. sum(1)(2)()

```js
class Animal { speak() { console.log("generic sound"); } }
class Dog extends Animal { speak() { console.log("bark"); } }

new Dog().speak(); // bark

```

## 20. Map vs WeakMap
Map: Any key type, strong references.

WeakMap: Object keys only, weak references ‚Üí garbage collected.

## 21. Component: Display Products & Details

```js
@Component({
  selector: 'app-products',
  template: `
    <ul>
      <li *ngFor="let product of products" (click)="select(product)">
        {{ product.name }}
      </li>
    </ul>
    <div *ngIf="selected">
      <h2>{{ selected.name }}</h2>
      <p>{{ selected.description }}</p>
    </div>
  `
})
export class ProductsComponent {
  products = [
    {name:'Laptop', description:'Dell XPS'},
    {name:'Phone', description:'iPhone'}
  ];
  selected: any;
  select(product) { this.selected = product; }
}


```


22. for-in vs for-of

for-in: Iterates keys (including inherited).

for-of: Iterates values (iterables only).


## 23. Prototype Inheritance & for-in

for-in iterates inherited properties too.
üëâ To avoid:

```js
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key);
  }
}


```


## 21. Component: Display Products & Details

```js
class Animal { speak() { console.log("generic sound"); } }
class Dog extends Animal { speak() { console.log("bark"); } }

new Dog().speak(); // bark

```

## 21. Component: Display Products & Details

```js
class Animal { speak() { console.log("generic sound"); } }
class Dog extends Animal { speak() { console.log("bark"); } }

new Dog().speak(); // bark

```

