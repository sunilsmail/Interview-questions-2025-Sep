# JavaScript, Angular & Design Concepts – Interview Q&A

---

## 1. Creating Set and Get Methods on Object Properties
<details> <summary>👉 Answer</summary>
You can define getters and setters using object shorthand or `Object.defineProperty`.

```js
const user = {
  firstName: "John",
  lastName: "Doe",
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(" ");
  },
};

console.log(user.fullName); // John Doe
user.fullName = "Jane Smith";
console.log(user.firstName); // Jane
```
</details>

2. target vs currentTarget
<details> <summary>👉 Answer</summary>

event.target → The actual element clicked.
event.currentTarget → The element the handler is attached to.
```js
document.querySelector("#parent").addEventListener("click", (e) => {
  console.log(e.target.id);        // child
  console.log(e.currentTarget.id); // parent
});
```
</details>

## 3. stopPropagation vs stopImmediatePropagation
<details> <summary>👉 Answer</summary>
stopPropagation() → Stops further bubbling/capturing.

stopImmediatePropagation() → Stops bubbling and prevents other listeners on the same element.

```htnl
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#cce5ff;">
      Parent
      <button id="child" style="margin:20px;">Click Me</button>
    </div>

    <script>
      // Parent listener
      document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked");
      });

      // Child listener 1
      document.getElementById("child").addEventListener("click", (e) => {
        console.log("Child listener 1");
        // Uncomment ONE of these lines at a time to see difference:
        // e.stopPropagation();
        // e.stopImmediatePropagation();
      });

      // Child listener 2
      document.getElementById("child").addEventListener("click", () => {
        console.log("Child listener 2");
      });
    </script>
  </body>
</html>

```
What happens:

Without any stop method

Child listener 1
Child listener 2
Parent clicked


With stopPropagation() inside listener 1

Child listener 1
Child listener 2


👉 Event doesn’t bubble to parent, but other listeners on the child still run.

With stopImmediatePropagation() inside listener 1

Child listener 1


👉 Stops bubbling and prevents Child listener 2 from running.
</details>

## 4. Currying
<details> <summary>👉 Answer</summary>
```js
function sum(a) {
  return (b) => (c) => a + b + c;
}
console.log(sum(1)(2)(3)); // 6

```
</details>

## 5. Higher Order Function
<details> <summary>👉 Answer</summary>
A function that takes another function as an argument or returns a function.

```js
function hof(fn, x) {
  return fn(x);
}
hof((n) => n * 2, 5); // 10

```
</details>

## 6. function sum(){} var sum; console.log(sum)

<details> <summary>👉 Answer</summary>
```js
function sum() {}
var sum;
console.log(sum); // function sum() {}

What happens under the hood:

Function declarations are hoisted first → The identifier sum is assigned to the function.

var declarations are hoisted next, but only the declaration (not assignment) is hoisted.

i.e. var sum; does nothing here because sum is already declared by the function.

So the final effective code is:

function sum() {}  // stays as is
// var sum; ← ignored because already declared
console.log(sum);  // logs function


✅ Function declarations take precedence over var declarations during hoisting.

🔹 Another Example (with assignment)
function sum() {}
var sum = 10;
console.log(sum);


👉 Output: 10
Because:

Function hoisted first (sum = function).

Then var sum hoisted (ignored, since already declared).

But assignment = 10 happens at runtime → overwrites function.
```
# JavaScript, Angular & Design Concepts – Interview Q&A

---

## 1. Creating Set and Get Methods on Object Properties
<details> <summary>👉 Answer</summary>
You can define getters and setters using object shorthand or `Object.defineProperty`.

```js
const user = {
  firstName: "John",
  lastName: "Doe",
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(" ");
  },
};

console.log(user.fullName); // John Doe
user.fullName = "Jane Smith";
console.log(user.firstName); // Jane
```
</details>

2. target vs currentTarget
<details> <summary>👉 Answer</summary>

event.target → The actual element clicked.
event.currentTarget → The element the handler is attached to.
```js
document.querySelector("#parent").addEventListener("click", (e) => {
  console.log(e.target.id);        // child
  console.log(e.currentTarget.id); // parent
});
```
</details>

## 3. stopPropagation vs stopImmediatePropagation
<details> <summary>👉 Answer</summary>
stopPropagation() → Stops further bubbling/capturing.

stopImmediatePropagation() → Stops bubbling and prevents other listeners on the same element.

```htnl
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#cce5ff;">
      Parent
      <button id="child" style="margin:20px;">Click Me</button>
    </div>

    <script>
      // Parent listener
      document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked");
      });

      // Child listener 1
      document.getElementById("child").addEventListener("click", (e) => {
        console.log("Child listener 1");
        // Uncomment ONE of these lines at a time to see difference:
        // e.stopPropagation();
        // e.stopImmediatePropagation();
      });

      // Child listener 2
      document.getElementById("child").addEventListener("click", () => {
        console.log("Child listener 2");
      });
    </script>
  </body>
</html>

```
What happens:

Without any stop method

Child listener 1
Child listener 2
Parent clicked


With stopPropagation() inside listener 1

Child listener 1
Child listener 2


👉 Event doesn’t bubble to parent, but other listeners on the child still run.

With stopImmediatePropagation() inside listener 1

Child listener 1


👉 Stops bubbling and prevents Child listener 2 from running.
</details>

## 4. Currying
<details> <summary>👉 Answer</summary>
```js
function sum(a) {
  return (b) => (c) => a + b + c;
}
console.log(sum(1)(2)(3)); // 6

```
</details>

## 5. Higher Order Function
<details> <summary>👉 Answer</summary>
A function that takes another function as an argument or returns a function.

```js
function hof(fn, x) {
  return fn(x);
}
hof((n) => n * 2, 5); // 10

```
</details>

## 6. function sum(){} var sum; console.log(sum)

<details> <summary>👉 Answer</summary>
```js
function sum() {}
var sum;
console.log(sum); // function sum() {}

What happens under the hood:

Function declarations are hoisted first → The identifier sum is assigned to the function.

var declarations are hoisted next, but only the declaration (not assignment) is hoisted.

i.e. var sum; does nothing here because sum is already declared by the function.

So the final effective code is:

function sum() {}  // stays as is
// var sum; ← ignored because already declared
console.log(sum);  // logs function


✅ Function declarations take precedence over var declarations during hoisting.

🔹 Another Example (with assignment)
function sum() {}
var sum = 10;
console.log(sum);


👉 Output: 10
Because:

Function hoisted first (sum = function).

Then var sum hoisted (ignored, since already declared).

But assignment = 10 happens at runtime → overwrites function.
```

</details>

## 7. Design Principle – DRY
<details> <summary>👉 Answer</summary>
Don’t Repeat Yourself (DRY): Extract common logic into reusable functions or modules.
</details>
## 8. Design Patterns
<details> <summary>👉 Answer</summary>
Reusable solutions:

Singleton

Ensure only one instance of a class/object exists.
```js
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance; // return existing instance
    }
    Singleton.instance = this;
    this.value = Math.random();
  }
}

const a = new Singleton();
const b = new Singleton();

console.log(a === b); // true
console.log(a.value, b.value); // same random value

```

Observer
One object (Subject) notifies multiple observers when something changes.
```js
class Subject {
  constructor() {
    this.observers = [];
  }
  subscribe(fn) {
    this.observers.push(fn);
  }
  notify(data) {
    this.observers.forEach(fn => fn(data));
  }
}

const subject = new Subject();
subject.subscribe((msg) => console.log("Observer 1:", msg));
subject.subscribe((msg) => console.log("Observer 2:", msg));

subject.notify("Hello Observers!");
O/P:
Observer 1: Hello Observers!
Observer 2: Hello Observers!
```

Factory
Creates objects without exposing the creation logic.
```js
class Car {
  drive() { console.log("Driving a car"); }
}
class Bike {
  drive() { console.log("Riding a bike"); }
}

class VehicleFactory {
  static create(type) {
    if (type === "car") return new Car();
    if (type === "bike") return new Bike();
  }
}

const v1 = VehicleFactory.create("car");
v1.drive(); // Driving a car

```

Decorator
Add new behavior to objects without modifying their code.
```js
function withLogger(fn) {
  return function(...args) {
    console.log("Calling with args:", args);
    return fn(...args);
  };
}

function add(a, b) {
  return a + b;
}

const loggedAdd = withLogger(add);
console.log(loggedAdd(2, 3)); // logs + returns 5

```

Module Pattern
Encapsulates code using IIFE (Immediately Invoked Function Expression).
```js
const CounterModule = (function () {
  let count = 0;

  return {
    increment() { count++; return count; },
    getCount() { return count; }
  };
})();

console.log(CounterModule.increment()); // 1
console.log(CounterModule.increment()); // 2
console.log(CounterModule.getCount());  // 2


These are minimal interview-friendly examples — small enough to memorize, but clear enough to demonstrate the concept.
```
</details>
## 9. Difference b/w Map & Reduce
<details> <summary>👉 Answer</summary>
map() → Transforms each element → returns array.

reduce() → Combines values → returns single result.
</details>
## 10. Update Array Without Modifying Reference
<details> <summary>👉 Answer</summary>
```js
const arr = [1, 2, 3, 4];
const updated = [...arr.slice(0, 2), 10, ...arr.slice(3)];
console.log(updated); // [1, 2, 10, 4]

```
</details>
## 11. Async Pipe in *ngFor
<details> <summary>👉 Answer</summary>
Using async directly in *ngFor → multiple subscriptions (performance issue).
✅ Better: assign observable to a variable via async with ngIf.
</details>
## 12. Custom Pipe, Resolver, Interceptor
<details> <summary>👉 Answer</summary>
```js
Pipe:

@Pipe({ name: 'capitalize' })
export class CapitalizePipe implements PipeTransform {
  transform(value: string): string {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
}
Resolver:

@Injectable({ providedIn: 'root' })
export class UserResolver implements Resolve<User> {
  constructor(private service: UserService) {}
  resolve() { return this.service.getUser(); }
}


Interceptor:

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req, next) {
    const cloned = req.clone({ setHeaders: { Authorization: 'token' } });
    return next.handle(cloned);
  }
}
```
</details>
## 13. Test Case for HTTP Request
<details> <summary>👉 Answer</summary>
```js
it('should call API', () => {
  const http = TestBed.inject(HttpTestingController);
  service.getData().subscribe(data => expect(data).toEqual({ name: 'test' }));
  const req = http.expectOne('/api/data');
  req.flush({ name: 'test' });
});

```
</details>
## 14. Event Bubbling vs Capturing vs Delegation
<details> <summary>👉 Answer</summary>
```js
Bubbling (child → parent)
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#cce5ff;">
      Parent
      <button id="child" style="margin:20px;">Click Me</button>
    </div>

    <script>
      document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked (bubbling)");
      });

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked (bubbling)");
      });
    </script>
  </body>
</html>


👉 Output when clicking Child:

Child clicked (bubbling)
Parent clicked (bubbling)

Capturing (parent → child)
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#f8d7da;">
      Parent
      <button id="child">Click Me</button>
    </div>

    <script>
      document.getElementById("parent").addEventListener(
        "click",
        () => {
          console.log("Parent clicked (capturing)");
        },
        true // 👈 capture mode enabled
      );

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked (capturing)");
      });
    </script>
  </body>
</html>
Output when clicking Child:

Parent clicked (capturing)
Child clicked (capturing)

Delegation (parent handles child events)
<!DOCTYPE html>
<html>
  <body>
    <ul id="list" style="cursor:pointer;">
      <li data-id="1">Item 1</li>
      <li data-id="2">Item 2</li>
      <li data-id="3">Item 3</li>
    </ul>

    <script>
      document.getElementById("list").addEventListener("click", (e) => {
        if (e.target.tagName === "LI") {
          console.log("Clicked item id:", e.target.dataset.id);
        }
      });
    </script>
  </body>
</html>


👉 Output when clicking Item 2:

Clicked item id: 2
```
</details>
## 15. Properties vs Attributes
<details> <summary>👉 Answer</summary>
Attributes: Present in HTML (e.g., <input value="abc">).

Properties: DOM object representation (input.value = "abc").
</details>
## 16. Pure vs Impure Pipe
<details> <summary>👉 Answer</summary>
Pure Pipe: Executes only when input changes.

Impure Pipe: Executes on every change detection.
</details>
## 17. innerText vs innerHTML
<details> <summary>👉 Answer</summary>
innerText: Returns visible text.

innerHTML: Returns/sets HTML including tags.
</details>
## 18. Polymorphism in JS
<details> <summary>👉 Answer</summary>
```js
function sum(a) {
  return (b) => () => a + b;
}
console.log(sum(1)(2)()); // 3


```
</details>

## 19. sum(1)(2)()
<details> <summary>👉 Answer</summary>
```js
class Animal { speak() { console.log("generic sound"); } }
class Dog extends Animal { speak() { console.log("bark"); } }

new Dog().speak(); // bark

```
</details>
## 20. Map vs WeakMap
<details> <summary>👉 Answer</summary>
Map: Any key type, strong references.

WeakMap: Object keys only, weak references → garbage collected.
</details>
## 21. Component: Display Products & Details
<details> <summary>👉 Answer</summary>
```js
@Component({
  selector: 'app-products',
  template: `
    <ul>
      <li *ngFor="let product of products" (click)="select(product)">
        {{ product.name }}
      </li>
    </ul>
    <div *ngIf="selected">
      <h2>{{ selected.name }}</h2>
      <p>{{ selected.description }}</p>
    </div>
  `
})
export class ProductsComponent {
  products = [
    {name:'Laptop', description:'Dell XPS'},
    {name:'Phone', description:'iPhone'}
  ];
  selected: any;
  select(product) { this.selected = product; }
}


```
</details>

22. for-in vs for-of
<details> <summary>👉 Answer</summary>
for-in: Iterates keys (including inherited).

for-of: Iterates values (iterables only).
</details>

## 23. Prototype Inheritance & for-in
<details> <summary>👉 Answer</summary>
for-in iterates inherited properties too.
👉 To avoid:

```js
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key);
  }
}


```

</details>


</details>

## 7. Design Principle – DRY
<details> <summary>👉 Answer</summary>
Don’t Repeat Yourself (DRY): Extract common logic into reusable functions or modules.
</details>
## 8. Design Patterns
<details> <summary>👉 Answer</summary>
Reusable solutions:

Singleton

Ensure only one instance of a class/object exists.
```js
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance; // return existing instance
    }
    Singleton.instance = this;
    this.value = Math.random();
  }
}

const a = new Singleton();
const b = new Singleton();

console.log(a === b); // true
console.log(a.value, b.value); // same random value

```

Observer
One object (Subject) notifies multiple observers when something changes.
```js
class Subject {
  constructor() {
    this.observers = [];
  }
  subscribe(fn) {
    this.observers.push(fn);
  }
  notify(data) {
    this.observers.forEach(fn => fn(data));
  }
}

const subject = new Subject();
subject.subscribe((msg) => console.log("Observer 1:", msg));
subject.subscribe((msg) => console.log("Observer 2:", msg));

subject.notify("Hello Observers!");
O/P:
Observer 1: Hello Observers!
Observer 2: Hello Observers!
```

Factory
Creates objects without exposing the creation logic.
```js
class Car {
  drive() { console.log("Driving a car"); }
}
class Bike {
  drive() { console.log("Riding a bike"); }
}

class VehicleFactory {
  static create(type) {
    if (type === "car") return new Car();
    if (type === "bike") return new Bike();
  }
}

const v1 = VehicleFactory.create("car");
v1.drive(); // Driving a car

```

Decorator
Add new behavior to objects without modifying their code.
```js
function withLogger(fn) {
  return function(...args) {
    console.log("Calling with args:", args);
    return fn(...args);
  };
}

function add(a, b) {
  return a + b;
}

const loggedAdd = withLogger(add);
console.log(loggedAdd(2, 3)); // logs + returns 5

```

Module Pattern
Encapsulates code using IIFE (Immediately Invoked Function Expression).
```js
const CounterModule = (function () {
  let count = 0;

  return {
    increment() { count++; return count; },
    getCount() { return count; }
  };
})();

console.log(CounterModule.increment()); // 1
console.log(CounterModule.increment()); // 2
console.log(CounterModule.getCount());  // 2


These are minimal interview-friendly examples — small enough to memorize, but clear enough to demonstrate the concept.
```
</details>
## 9. Difference b/w Map & Reduce
<details> <summary>👉 Answer</summary>
map() → Transforms each element → returns array.

reduce() → Combines values → returns single result.
</details>
## 10. Update Array Without Modifying Reference
<details> <summary>👉 Answer</summary>
```js
const arr = [1, 2, 3, 4];
const updated = [...arr.slice(0, 2), 10, ...arr.slice(3)];
console.log(updated); // [1, 2, 10, 4]

```
</details>
## 11. Async Pipe in *ngFor
<details> <summary>👉 Answer</summary>
Using async directly in *ngFor → multiple subscriptions (performance issue).
✅ Better: assign observable to a variable via async with ngIf.
</details>
## 12. Custom Pipe, Resolver, Interceptor
<details> <summary>👉 Answer</summary>
```js
Pipe:

@Pipe({ name: 'capitalize' })
export class CapitalizePipe implements PipeTransform {
  transform(value: string): string {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
}
Resolver:

@Injectable({ providedIn: 'root' })
export class UserResolver implements Resolve<User> {
  constructor(private service: UserService) {}
  resolve() { return this.service.getUser(); }
}


Interceptor:

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req, next) {
    const cloned = req.clone({ setHeaders: { Authorization: 'token' } });
    return next.handle(cloned);
  }
}
```
</details>
## 13. Test Case for HTTP Request
<details> <summary>👉 Answer</summary>
```js
it('should call API', () => {
  const http = TestBed.inject(HttpTestingController);
  service.getData().subscribe(data => expect(data).toEqual({ name: 'test' }));
  const req = http.expectOne('/api/data');
  req.flush({ name: 'test' });
});

```
</details>
## 14. Event Bubbling vs Capturing vs Delegation
<details> <summary>👉 Answer</summary>
```js
Bubbling (child → parent)
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#cce5ff;">
      Parent
      <button id="child" style="margin:20px;">Click Me</button>
    </div>

    <script>
      document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked (bubbling)");
      });

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked (bubbling)");
      });
    </script>
  </body>
</html>


👉 Output when clicking Child:

Child clicked (bubbling)
Parent clicked (bubbling)

Capturing (parent → child)
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#f8d7da;">
      Parent
      <button id="child">Click Me</button>
    </div>

    <script>
      document.getElementById("parent").addEventListener(
        "click",
        () => {
          console.log("Parent clicked (capturing)");
        },
        true // 👈 capture mode enabled
      );

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked (capturing)");
      });
    </script>
  </body>
</html>
Output when clicking Child:

Parent clicked (capturing)
Child clicked (capturing)

Delegation (parent handles child events)
<!DOCTYPE html>
<html>
  <body>
    <ul id="list" style="cursor:pointer;">
      <li data-id="1">Item 1</li>
      <li data-id="2">Item 2</li>
      <li data-id="3">Item 3</li>
    </ul>

    <script>
      document.getElementById("list").addEventListener("click", (e) => {
        if (e.target.tagName === "LI") {
          console.log("Clicked item id:", e.target.dataset.id);
        }
      });
    </script>
  </body>
</html>


👉 Output when clicking Item 2:

Clicked item id: 2
```
</details>
## 15. Properties vs Attributes
<details> <summary>👉 Answer</summary>
Attributes: Present in HTML (e.g., <input value="abc">).

Properties: DOM object representation (input.value = "abc").
</details>
## 16. Pure vs Impure Pipe
<details> <summary>👉 Answer</summary>
Pure Pipe: Executes only when input changes.

Impure Pipe: Executes on every change detection.
</details>
## 17. innerText vs innerHTML
<details> <summary>👉 Answer</summary>
innerText: Returns visible text.

innerHTML: Returns/sets HTML including tags.
</details>
## 18. Polymorphism in JS
<details> <summary>👉 Answer</summary>
```js
function sum(a) {
  return (b) => () => a + b;
}
console.log(sum(1)(2)()); // 3


```
</details>

## 19. sum(1)(2)()
<details> <summary>👉 Answer</summary>
```js
class Animal { speak() { console.log("generic sound"); } }
class Dog extends Animal { speak() { console.log("bark"); } }

new Dog().speak(); // bark

```
</details>
## 20. Map vs WeakMap
<details> <summary>👉 Answer</summary>
Map: Any key type, strong references.

WeakMap: Object keys only, weak references → garbage collected.
</details>
## 21. Component: Display Products & Details
<details> <summary>👉 Answer</summary>
```js
@Component({
  selector: 'app-products',
  template: `
    <ul>
      <li *ngFor="let product of products" (click)="select(product)">
        {{ product.name }}
      </li>
    </ul>
    <div *ngIf="selected">
      <h2>{{ selected.name }}</h2>
      <p>{{ selected.description }}</p>
    </div>
  `
})
export class ProductsComponent {
  products = [
    {name:'Laptop', description:'Dell XPS'},
    {name:'Phone', description:'iPhone'}
  ];
  selected: any;
  select(product) { this.selected = product; }
}


```
</details>

22. for-in vs for-of
<details> <summary>👉 Answer</summary>
for-in: Iterates keys (including inherited).

for-of: Iterates values (iterables only).
</details>

## 23. Prototype Inheritance & for-in
<details> <summary>👉 Answer</summary>
for-in iterates inherited properties too.
👉 To avoid:

```js
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key);
  }
}


```

</details>
