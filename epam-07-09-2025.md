# JavaScript, Angular & Design Concepts â€“ Interview Q&A



## 1. Creating Set and Get Methods on Object Properties
<details> <summary>ðŸ‘‰ Answer</summary>

You can define getters and setters using object shorthand or `Object.defineProperty`.

```js
const user = {
  firstName: "John",
  lastName: "Doe",
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(" ");
  },
};

console.log(user.fullName); // John Doe
user.fullName = "Jane Smith";
console.log(user.firstName); // Jane
```

</details>


## 2. target vs currentTarget

<details> <summary>ðŸ‘‰ Answer</summary>
event.target â†’ The actual element clicked.

event.currentTarget â†’ The element the handler is attached to.
```js
document.querySelector("#parent").addEventListener("click", (e) => {
  console.log(e.target.id);        // child
  console.log(e.currentTarget.id); // parent
});

```
</details>

## 3. stopPropagation vs stopImmediatePropagation
<details> <summary>ðŸ‘‰ Answer</summary>
stopPropagation() â†’ Stops further bubbling/capturing.

stopImmediatePropagation() â†’ Stops bubbling and prevents other listeners on the same element.

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#cce5ff;">
      Parent
      <button id="child" style="margin:20px;">Click Me</button>
    </div>

    <script>
      // Parent listener
      document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked");
      });

      // Child listener 1
      document.getElementById("child").addEventListener("click", (e) => {
        console.log("Child listener 1");
        // Uncomment ONE of these lines at a time to see difference:
        // e.stopPropagation();
        // e.stopImmediatePropagation();
      });

      // Child listener 2
      document.getElementById("child").addEventListener("click", () => {
        console.log("Child listener 2");
      });
    </script>
  </body>
</html>
Scenarios:

No stop â†’ Child 1 â†’ Child 2 â†’ Parent

With stopPropagation() â†’ Child 1 â†’ Child 2

With stopImmediatePropagation() â†’ Child 1 only
```

</details>

## 4. Currying
<details> <summary>ðŸ‘‰ Answer</summary>
```js
function sum(a) {
  return (b) => (c) => a + b + c;
}
console.log(sum(1)(2)(3)); // 6
```
</details>

## 5. Higher Order Function
<details> <summary>ðŸ‘‰ Answer</summary>
A function that takes another function as an argument or returns a function.
```js
function hof(fn, x) {
  return fn(x);
}
console.log(hof((n) => n * 2, 5)); // 10
```
</details>

## 6. Function vs var Hoisting
<details> <summary>ðŸ‘‰ Answer</summary>
```js
function sum() {}
var sum;
console.log(sum); // function sum() {}
```
Explanation
Function declarations are hoisted first.

var declarations are hoisted next, but only the declaration (not assignment).

âœ… Function declarations take precedence over var declarations during hoisting.

ðŸ”¹ Another example:
```js
function sum() {}
var sum = 10;
console.log(sum); // 10
Here, the function is hoisted first, but assignment = 10 happens at runtime overwrites the function.
```
</details>


## 7. Design Principle â€“ DRY
<details> <summary>ðŸ‘‰ Answer</summary>
Donâ€™t Repeat Yourself (DRY): Extract common logic into reusable functions or modules.

</details>

## 8. Design Patterns
<details> <summary>ðŸ‘‰ Answer</summary>
Singleton
Ensure only one instance exists.
```js
class Singleton {
  constructor() {
    if (Singleton.instance) return Singleton.instance;
    Singleton.instance = this;
    this.value = Math.random();
  }
}

const a = new Singleton();
const b = new Singleton();
console.log(a === b); // true
console.log(a.value, b.value); // same random value
```
Observer
Notify multiple observers when something changes.
```js
class Subject {
  constructor() {
    this.observers = [];
  }
  subscribe(fn) {
    this.observers.push(fn);
  }
  notify(data) {
    this.observers.forEach(fn => fn(data));
  }
}

const subject = new Subject();
subject.subscribe((msg) => console.log("Observer 1:", msg));
subject.subscribe((msg) => console.log("Observer 2:", msg));

subject.notify("Hello Observers!");
// Observer 1: Hello Observers!
// Observer 2: Hello Observers!
```
Factory
Creates objects without exposing creation logic.
```js
class Car { drive() { console.log("Driving a car"); } }
class Bike { drive() { console.log("Riding a bike"); } }

class VehicleFactory {
  static create(type) {
    if (type === "car") return new Car();
    if (type === "bike") return new Bike();
  }
}

const v1 = VehicleFactory.create("car");
v1.drive(); // Driving a car
```
Decorator
Add new behavior without modifying original code.
```js
function withLogger(fn) {
  return function(...args) {
    console.log("Calling with args:", args);
    return fn(...args);
  };
}

function add(a, b) {
  return a + b;
}

const loggedAdd = withLogger(add);
console.log(loggedAdd(2, 3)); // logs + returns 5
```
Module Pattern
Encapsulates code using IIFE.
```js
const CounterModule = (function () {
  let count = 0;

  return {
    increment() { count++; return count; },
    getCount() { return count; }
  };
})();

console.log(CounterModule.increment()); // 1
console.log(CounterModule.increment()); // 2
console.log(CounterModule.getCount());  // 2
```
</details>

## 9. Difference b/w Map & Reduce
<details> <summary>ðŸ‘‰ Answer</summary>
map() â†’ Transforms each element â†’ returns array.

reduce() â†’ Combines values â†’ returns single result.
</details>

## 10. Update Array Without Modifying Reference
<details> <summary>ðŸ‘‰ Answer</summary>
```js
const arr = [1, 2, 3, 4];
const updated = [...arr.slice(0, 2), 10, ...arr.slice(3)];
console.log(updated); // [1, 2, 10, 4]

```
</details>

## 11. Async Pipe in *ngFor
<details> <summary>ðŸ‘‰ Answer</summary>
Using async directly in *ngFor â†’ multiple subscriptions (performance issue).
âœ… Better: assign observable to a variable via async with ngIf.
</details>

## 12. Custom Pipe, Resolver, Interceptor
<details> <summary>ðŸ‘‰ Answer</summary>
```js
Pipe:

@Pipe({ name: 'capitalize' })
export class CapitalizePipe implements PipeTransform {
  transform(value: string): string {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
}
Resolver:

@Injectable({ providedIn: 'root' })
export class UserResolver implements Resolve<User> {
  constructor(private service: UserService) {}
  resolve() { return this.service.getUser(); }
}


Interceptor:

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req, next) {
    const cloned = req.clone({ setHeaders: { Authorization: 'token' } });
    return next.handle(cloned);
  }
}
```
</details>

## 13. Test Case for HTTP Request
<details> <summary>ðŸ‘‰ Answer</summary>
```js
it('should call API', () => {
  const http = TestBed.inject(HttpTestingController);
  service.getData().subscribe(data => expect(data).toEqual({ name: 'test' }));
  const req = http.expectOne('/api/data');
  req.flush({ name: 'test' });
});

```
</details>

## 14. Event Bubbling vs Capturing vs Delegation
<details> <summary>ðŸ‘‰ Answer</summary>
```js
Bubbling (child â†’ parent)
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#cce5ff;">
      Parent
      <button id="child" style="margin:20px;">Click Me</button>
    </div>

    <script>
      document.getElementById("parent").addEventListener("click", () => {
        console.log("Parent clicked (bubbling)");
      });

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked (bubbling)");
      });
    </script>
  </body>
</html>


ðŸ‘‰ Output when clicking Child:

Child clicked (bubbling)
Parent clicked (bubbling)

Capturing (parent â†’ child)
<!DOCTYPE html>
<html>
  <body>
    <div id="parent" style="padding:30px; background:#f8d7da;">
      Parent
      <button id="child">Click Me</button>
    </div>

    <script>
      document.getElementById("parent").addEventListener(
        "click",
        () => {
          console.log("Parent clicked (capturing)");
        },
        true // ðŸ‘ˆ capture mode enabled
      );

      document.getElementById("child").addEventListener("click", () => {
        console.log("Child clicked (capturing)");
      });
    </script>
  </body>
</html>
Output when clicking Child:

Parent clicked (capturing)
Child clicked (capturing)

Delegation (parent handles child events)
<!DOCTYPE html>
<html>
  <body>
    <ul id="list" style="cursor:pointer;">
      <li data-id="1">Item 1</li>
      <li data-id="2">Item 2</li>
      <li data-id="3">Item 3</li>
    </ul>

    <script>
      document.getElementById("list").addEventListener("click", (e) => {
        if (e.target.tagName === "LI") {
          console.log("Clicked item id:", e.target.dataset.id);
        }
      });
    </script>
  </body>
</html>


ðŸ‘‰ Output when clicking Item 2:

Clicked item id: 2
```
</details>

## 15. Properties vs Attributes
<details> <summary>ðŸ‘‰ Answer</summary>
Attributes: Present in HTML (e.g., <input value="abc">).

Properties: DOM object representation (input.value = "abc").
</details>

## 16. Pure vs Impure Pipe
<details> <summary>ðŸ‘‰ Answer</summary>
Pure Pipe: Executes only when input changes.

Impure Pipe: Executes on every change detection.
</details>

## 17. innerText vs innerHTML
<details> <summary>ðŸ‘‰ Answer</summary>
innerText: Returns visible text.

innerHTML: Returns/sets HTML including tags.
</details>

## 18. Polymorphism in JS
<details> <summary>ðŸ‘‰ Answer</summary>
```js
function sum(a) {
  return (b) => () => a + b;
}
console.log(sum(1)(2)()); // 3


```
</details>


## 19. sum(1)(2)()
<details> <summary>ðŸ‘‰ Answer</summary>
```js
class Animal { speak() { console.log("generic sound"); } }
class Dog extends Animal { speak() { console.log("bark"); } }

new Dog().speak(); // bark

```
</details>

## 20. Map vs WeakMap
<details> <summary>ðŸ‘‰ Answer</summary>
Map: Any key type, strong references.

WeakMap: Object keys only, weak references â†’ garbage collected.
</details>

## 21. Component: Display Products & Details
<details> <summary>ðŸ‘‰ Answer</summary>
```js
@Component({
  selector: 'app-products',
  template: `
    <ul>
      <li *ngFor="let product of products" (click)="select(product)">
        {{ product.name }}
      </li>
    </ul>
    <div *ngIf="selected">
      <h2>{{ selected.name }}</h2>
      <p>{{ selected.description }}</p>
    </div>
  `
})
export class ProductsComponent {
  products = [
    {name:'Laptop', description:'Dell XPS'},
    {name:'Phone', description:'iPhone'}
  ];
  selected: any;
  select(product) { this.selected = product; }
}


```
</details>


22. for-in vs for-of
<details> <summary>ðŸ‘‰ Answer</summary>
for-in: Iterates keys (including inherited).

for-of: Iterates values (iterables only).
</details>


## 23. Prototype Inheritance & for-in
<details> <summary>ðŸ‘‰ Answer</summary>
for-in iterates inherited properties too.
ðŸ‘‰ To avoid:

```js
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key);
  }
}


```
</details>

22. for-in vs for-of
<details> <summary>ðŸ‘‰ Answer</summary>
for-in: Iterates keys (including inherited).

for-of: Iterates values (iterables only).
</details>


## 23. Prototype Inheritance & for-in
<details> <summary>ðŸ‘‰ Answer</summary>
for-in iterates inherited properties too.
ðŸ‘‰ To avoid:

```js
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key);
  }
}
```
</details>
